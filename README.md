# 莲语 lianyu-rpc 框架

【说明】本项目参考程序员鱼皮 yu-rpc 实现

基于 Java + Etcd + Vert.x 自定义协议实现。 

## 1.简易版 RPC 框架实现
![rpc-easy.png](rpc-easy.png)
服务提供者在启动时将其服务接口和实现注册到本地服务注册器中。
当服务消费者需要调用远程服务时，它通过请求客户端发送请求，该请求随后被RPC框架接收并序列化。
接着，Web服务器将请求转发给请求处理器，后者调用本地注册的服务实现来执行具体的业务逻辑。
服务执行完毕后，结果被返回给请求处理器，然后经过反序列化处理，最终发送回给消费者，完成整个远程调用过程。

## 2.全局配置加载

在RPC框架运行的过程中，会涉及到很多的配置信息，比如注册中心地址、序列化方式、网络服务端口号等。
在简易版中硬编码了这些配置，不利于维护。而且RPC框架是需要被其他项目作为服务提供者或服务消费者引入的，
我们应当允许引入框架的项目通过编写配置文件来 **自定义配置**。

## 3.接口mock
RPC框架的核心功能是调用其他远程服务。但是实际开发和测试过程中，有时可能无法直接访问真实的远程服务，或者访问真实的远程服务
可能会产生不可控的影响，例如网络延迟、服务不稳定等。在这种情况下，就需要使用 mock 服务来模拟远程服务的行为，以便进行接口的测试、开发和调试。
最简单的方式，通过动态代理创建一个**调用方法时返回固定值**的对象。

## 4.序列化器与 SPI 机制
Java对象是存活在虚拟机中的，如果想要在其他位置存储并访问、或者在网络中传输，就需要序列化和反序列化。
之前是在代码里硬编码了jdk序列化器，理想情况下，应该通过配置文件指定使用的自定义序列化器，根据配置来获取不同的序列化器。
SPI（Service Provider Interface）服务提供接口是 Java 的机制，主要用于实现模块化开发和插件化开发。
SPI 机制允许服务提供者通过特定的配置文件将自己的实现注册到系统中，然后通过反射机制动态加载这些实现，而不需要修改原始框架的代码。

## 5.注册中心的基本实现
RPC 框架的一个核心模块是注册中心，目的是帮助消费者获取到服务提供者的调用地址，而不是将调用地址硬编码到项目中。
注册中心的核心能力：
1. 数据分布式存储：集中的注册信息数据存储、读取和共享
2. 服务注册：服务提供者桑宝服务信息到注册中心
3. 服务发现：服务消费者从注册中心拉取服务信息
4. 心跳检测：定期检查服务提供者的存活状态
5. 服务注销：手动剔除节点、或者自动剔除失效节点
6. 更多优化点：比如注册中心本身的容错、服务消费者缓存等

ETCD 是一个 Go 语言实现的、开源的、分布式的键值存储系统，它主要用于分布式系统中的服务发现、配置管理和
分布式锁等场景。
除了性能之外，Etcd 采用 Raft 一致性算法来保证数据的一致性和可靠性，具有高可用性、强一致性、分布式特性等特点。

## 6.注册中心优化
1. 心跳检测和续期机制
    - 心跳检测是一种用于检测系统是否正常工作的机制。它通过定期发送**心跳信号**来检测目标系统的状态。
    - 因为 Etcd 自带了key过期机制，给节点处册信息一个生命倒计时，让节点定期续期，重置自己的倒计时。
    - 如果节点已宕机，一直不续期，Etcd就会对key进行过期删除。
2. 服务节点下线机制
    - 当服务提供者节点宕机时，应该从注册中心移除掉已注册的节点，否则会影响消费端调用。
    - 主动下线：服务提供者项目正常退出时，主动从注册中心移除注册信息。利用JVM的Shutdown（允许开发者在JVM即将关闭之前执行一些清理工作或其他必要的操作）就能实现。
    - 被动下线：服务提供者项目异常退出时，利用 Etcd 的 key 过期机制自动移除。
3. 消费者服务缓存

    正常情况下，服务节点信息列表的更新频率是不高的，所以在服务消费者从注册中心获取到服务节点信息列表后，完全可以缓存到本地，
下次就不用再请求注册中心获取了，能够提高性能。
    - 本地缓存的实现用一个列表来存储服务信息即可。
    - 服务缓存更新需要使用 Etcd 的 watch 监听机制，当监听的某个 key 发生修改或删除时，就会触发事件来通知监听者。
    - 由于目标是更新缓存，缓存是在服务消费端维护和使用的，所以也应该是服务消费端去watch。只有在服务消费者执行的方法中，可以创建watch监听器，
    那么比较合适的位置就是服务发现方法（serverDiscovery）。可以对本次获取到的所有服务节点 key 进行监听。